#! /bin/sh /usr/share/dpatch/dpatch-run
## daemon downtime: Handle loading effective downtime from retention
##
## All lines beginning with `## DP:' are a description of the patch.
## DP: From 9f18395268dda948265722984097735d48d72197 Mon Sep 17 00:00:00 2001
## DP: From: Andreas Ericsson <ae@op5.se>
## DP: Date: Wed, 6 Jun 2012 09:38:06 +0000
## DP: Subject: [PATCH] daemon downtime: Handle loading effective downtime from
## DP:  retention
## DP: 
## DP: Without this patch, Nagios would forget about downtime that starts
## DP: before the core is stopped and ends after the core is restarted.
## DP: 
## DP: According to testers, the original problem with notifications being
## DP: re-sent does not crop up again when this patch is applied.
## DP: 
## DP: Tested-by: Mark Elsen <mark.elsen@gmail.com>
## DP: Tested-by: Phil Randal <phil.randal@hoopleltd.co.uk>
## DP: Patched-by: Carlos Velasco <carlos.velasco@nimastelecom.com>
## DP: Signed-off-by: Andreas Ericsson <ae@op5.se>
## DP: 
## DP: git-svn-id: https://nagios.svn.sourceforge.net/svnroot/nagios/nagioscore/trunk@1953 5f96b256-904b-4d8d-8c98-d829582c6739
## DP: ---
## DP:  THANKS            |  1 +
## DP:  common/downtime.c | 31 +++++++++++++++++++++++++++----
## DP:  2 files changed, 28 insertions(+), 4 deletions(-)

@DPATCH@
diff --git a/THANKS b/THANKS
index d2f759a..b7c666e 100644
--- a/THANKS
+++ b/THANKS
@@ -277,6 +277,7 @@ since 1999.  If I missed your name, let me know.
 * Nikola Vassilev
 * Esteban Manchado Velazquez
 * Geert Vanderkelen
+* Carlos Velasco
 * Jan Vejvalka
 * Robert August Vincent II
 * Dave Viner
diff --git a/common/downtime.c b/common/downtime.c
index 09a0333..0193c50 100644
--- a/common/downtime.c
+++ b/common/downtime.c
@@ -401,11 +401,34 @@ int handle_scheduled_downtime(scheduled_downtime *temp_downtime) {
 		}
 
 	/* if downtime handler gets triggerd in between then there seems to be a restart */
-	/* Don't do anything just return */
-	time( &current_time);
-	if( temp_downtime->start_time < current_time && current_time < temp_downtime->end_time && temp_downtime->is_in_effect == TRUE)
-		return OK;
+	time(&current_time);
+	if(temp_downtime->start_time < current_time && current_time < temp_downtime->end_time && temp_downtime->is_in_effect == TRUE) {
+#ifdef USE_EVENT_BROKER
+		/* send data to event broker */
+		broker_downtime_data(NEBTYPE_DOWNTIME_START, NEBFLAG_NONE, NEBATTR_NONE, temp_downtime->type, temp_downtime->host_name, temp_downtime->service_description, temp_downtime->entry_time, temp_downtime->author, temp_downtime->comment, temp_downtime->start_time, temp_downtime->end_time, temp_downtime->fixed, temp_downtime->triggered_by, temp_downtime->duration, temp_downtime->downtime_id, NULL);
+#endif
+
+		/* increment the downtime depth variable */
+		if(temp_downtime->type == HOST_DOWNTIME) {
+			hst->scheduled_downtime_depth++;
+			update_host_status(hst, FALSE);
+			}
+		else {
+			svc->scheduled_downtime_depth++;
+			update_service_status(svc, FALSE);
+			}
 
+		/* schedule an event */
+		if(temp_downtime->fixed == FALSE)
+			event_time = (time_t)((unsigned long)time(NULL) + temp_downtime->duration);
+		else
+			event_time = temp_downtime->end_time;
+		if((new_downtime_id = (unsigned long *)malloc(sizeof(unsigned long)))) {
+			*new_downtime_id = temp_downtime->downtime_id;
+			schedule_new_event(EVENT_SCHEDULED_DOWNTIME, TRUE, event_time, FALSE, 0, NULL, FALSE, (void *)new_downtime_id, NULL, 0);
+			}
+		return OK;
+		}
 
 	/* have we come to the end of the scheduled downtime? */
 	if(temp_downtime->is_in_effect == TRUE) {
-- 
1.8.2

